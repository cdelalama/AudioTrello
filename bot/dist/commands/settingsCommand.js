"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupSettingsCommand = setupSettingsCommand;
const grammy_1 = require("grammy");
const trelloKeyboards_1 = require("../keyboards/trelloKeyboards");
const userService_1 = require("../services/userService");
const trelloService_1 = require("../services/trelloService");
const settingsKeyboard_1 = require("../keyboards/settingsKeyboard");
function setupSettingsCommand(bot) {
    bot.command("settings", async (ctx) => {
        try {
            const user = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            if (!user) {
                await ctx.reply("‚ùå Usuario no encontrado");
                return;
            }
            await ctx.reply("‚öôÔ∏è Configuraci√≥n de Trello", {
                reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(user),
            });
        }
        catch (error) {
            console.error("Error in settings command:", error);
            await ctx.reply("‚ùå Error al acceder a la configuraci√≥n");
        }
    });
    // Manejador para ver configuraci√≥n actual
    bot.callbackQuery("settings_view", async (ctx) => {
        try {
            const user = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            if (!user) {
                await ctx.answerCallbackQuery("‚ùå Usuario no encontrado");
                return;
            }
            const message = `üîß *Configuraci√≥n Actual*\n\n` +
                `*Tablero:* ${!user.default_board_name ||
                    user.default_board_name === null ||
                    user.default_board_name === ""
                    ? "‚ùå No configurado"
                    : user.default_board_name}\n` +
                `*Lista:* ${!user.default_list_name ||
                    user.default_list_name === null ||
                    user.default_list_name === ""
                    ? "‚ùå No configurado"
                    : user.default_list_name}\n` +
                `*Token Trello:* ${user.trello_token ? "‚úÖ Configurado" : "‚ùå No configurado"}`;
            try {
                await ctx.editMessageText(message, {
                    parse_mode: "Markdown",
                    reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(user),
                });
            }
            catch (editError) {
                // Si el error es porque el mensaje es el mismo, solo respondemos con un callback
                if (editError.description?.includes("message is not modified")) {
                    await ctx.answerCallbackQuery("‚úÖ Configuraci√≥n actualizada");
                    return;
                }
                throw editError; // Re-lanzar otros errores
            }
        }
        catch (error) {
            console.error("Error viewing settings:", error);
            const fallbackUser = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            await ctx.editMessageText("‚ùå Error al mostrar la configuraci√≥n. Int√©ntalo de nuevo.", {
                reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(fallbackUser || { id: 0 }),
            });
        }
    });
    // Manejador para configurar tablero
    bot.callbackQuery("settings_board", async (ctx) => {
        try {
            const user = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            if (!user?.trello_token) {
                await ctx.editMessageText("‚ùå Necesitas autenticarte con Trello primero", {
                    reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(user || { id: 0 }),
                });
                return;
            }
            const boards = await trelloService_1.TrelloService.getBoards(user.trello_token);
            if (!boards.length) {
                await ctx.editMessageText("‚ùå No se encontraron tableros en tu cuenta de Trello", {
                    reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(user || { id: 0 }),
                });
                return;
            }
            await ctx.editMessageText("üìã Selecciona un tablero:", {
                reply_markup: (0, trelloKeyboards_1.createBoardsKeyboard)(boards),
            });
        }
        catch (error) {
            console.error("Error getting boards:", error);
            const fallbackUser = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            await ctx.editMessageText("‚ùå Error al obtener los tableros", {
                reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(fallbackUser || { id: 0 }),
            });
        }
    });
    // Manejador para selecci√≥n de tablero
    bot.callbackQuery(/select_board:(.+)/, async (ctx) => {
        try {
            const boardId = ctx.match[1];
            const user = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            if (!user?.trello_token)
                return;
            const boards = await trelloService_1.TrelloService.getBoards(user.trello_token);
            const selectedBoard = boards.find((b) => b.id === boardId);
            if (!selectedBoard)
                return;
            await userService_1.userService.updateUser(user.id, {
                default_board_id: boardId,
                default_board_name: selectedBoard.name,
            });
            const lists = await trelloService_1.TrelloService.getLists(boardId, user.trello_token);
            await ctx.editMessageText(`‚úÖ Tablero seleccionado: *${selectedBoard.name}*\n\nAhora selecciona una lista:`, {
                parse_mode: "Markdown",
                reply_markup: (0, trelloKeyboards_1.createListsKeyboard)(lists),
            });
        }
        catch (error) {
            console.error("Error selecting board:", error);
            const fallbackUser = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            await ctx.editMessageText("‚ùå Error al seleccionar el tablero", {
                reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(fallbackUser || { id: 0 }),
            });
        }
    });
    // Manejador para navegaci√≥n de p√°ginas de tableros
    bot.callbackQuery(/boards_page:(\d+)/, async (ctx) => {
        try {
            const page = parseInt(ctx.match[1]);
            const user = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            if (!user?.trello_token)
                return;
            const boards = await trelloService_1.TrelloService.getBoards(user.trello_token);
            await ctx.editMessageText("üìã Selecciona un tablero:", {
                reply_markup: (0, trelloKeyboards_1.createBoardsKeyboard)(boards, page),
            });
        }
        catch (error) {
            console.error("Error navigating boards:", error);
            await ctx.answerCallbackQuery("‚ùå Error al navegar los tableros");
        }
    });
    // Manejador para selecci√≥n de lista
    bot.callbackQuery(/select_list:(.+)/, async (ctx) => {
        try {
            const listId = ctx.match[1];
            const user = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            if (!user?.trello_token || !user.default_board_id)
                return;
            const lists = await trelloService_1.TrelloService.getLists(user.default_board_id, user.trello_token);
            const selectedList = lists.find((l) => l.id === listId);
            if (!selectedList)
                return;
            await userService_1.userService.updateUser(user.id, {
                default_list_id: listId,
                default_list_name: selectedList.name,
            });
            await ctx.editMessageText("‚úÖ Configuraci√≥n guardada:\n\n" +
                `*Tablero:* ${user.default_board_name}\n` +
                `*Lista:* ${selectedList.name}`, {
                parse_mode: "Markdown",
                reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(user || { id: 0 }),
            });
        }
        catch (error) {
            console.error("Error selecting list:", error);
            const fallbackUser = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            await ctx.editMessageText("‚ùå Error al seleccionar la lista", {
                reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(fallbackUser || { id: 0 }),
            });
        }
    });
    // Manejador para cancelar la configuraci√≥n
    bot.callbackQuery("settings_cancel", async (ctx) => {
        try {
            const user = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            if (!user) {
                await ctx.answerCallbackQuery("‚ùå Usuario no encontrado");
                return;
            }
            await ctx.editMessageText("‚öôÔ∏è Configuraci√≥n de Trello", {
                reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(user || { id: 0 }),
            });
        }
        catch (error) {
            console.error("Error in settings cancel:", error);
            const fallbackUser = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            await ctx.editMessageText("‚öôÔ∏è Configuraci√≥n de Trello", {
                reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(fallbackUser || { id: 0 }),
            });
        }
    });
    // Manejador para configurar lista directamente
    bot.callbackQuery("settings_list", async (ctx) => {
        try {
            const user = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            if (!user?.trello_token) {
                await ctx.editMessageText("‚ùå Necesitas autenticarte con Trello primero", {
                    reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(user || { id: 0 }),
                });
                return;
            }
            if (!user.default_board_id) {
                await ctx.editMessageText("‚ùå Primero debes seleccionar un tablero", {
                    reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(user || { id: 0 }),
                });
                return;
            }
            const lists = await trelloService_1.TrelloService.getLists(user.default_board_id, user.trello_token);
            await ctx.editMessageText(`üìã Selecciona una lista del tablero *${user.default_board_name}*:`, {
                parse_mode: "Markdown",
                reply_markup: (0, trelloKeyboards_1.createListsKeyboard)(lists),
            });
        }
        catch (error) {
            console.error("Error getting lists:", error);
            const fallbackUser = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            await ctx.editMessageText("‚ùå Error al obtener las listas", {
                reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(fallbackUser || { id: 0 }),
            });
        }
    });
    // Manejador para desconectar Trello
    bot.callbackQuery("settings_disconnect", async (ctx) => {
        try {
            const user = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            if (!user) {
                await ctx.answerCallbackQuery("‚ùå Usuario no encontrado");
                return;
            }
            // Preguntar confirmaci√≥n
            await ctx.editMessageText("‚ö†Ô∏è *¬øEst√°s seguro de que quieres desconectar Trello?*\n\n" +
                "Se eliminar√°n todas tus configuraciones actuales.", {
                parse_mode: "Markdown",
                reply_markup: new grammy_1.InlineKeyboard()
                    .text("‚úÖ S√≠, desconectar", "settings_disconnect_confirm")
                    .text("‚ùå No, cancelar", "settings_cancel"),
            });
        }
        catch (error) {
            console.error("Error in disconnect prompt:", error);
            await ctx.answerCallbackQuery("‚ùå Error al procesar la solicitud");
        }
    });
    // Manejador para confirmar desconexi√≥n
    bot.callbackQuery("settings_disconnect_confirm", async (ctx) => {
        try {
            const user = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            if (!user) {
                await ctx.answerCallbackQuery("‚ùå Usuario no encontrado");
                return;
            }
            const success = await userService_1.userService.disconnectTrello(user.id);
            if (success) {
                await ctx.editMessageText("‚úÖ Trello desconectado correctamente\n\n" +
                    "Se han eliminado todas las configuraciones.", {
                    reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(user || { id: 0 }),
                });
            }
            else {
                await ctx.editMessageText("‚ùå Error al desconectar Trello", {
                    reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(user || { id: 0 }),
                });
            }
        }
        catch (error) {
            console.error("Error disconnecting Trello:", error);
            const fallbackUser = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            await ctx.editMessageText("‚ùå Error al desconectar Trello", {
                reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(fallbackUser || { id: 0 }),
            });
        }
    });
    // Manejador para conectar Trello
    bot.callbackQuery("settings_connect", async (ctx) => {
        try {
            const user = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            if (!user) {
                await ctx.answerCallbackQuery("‚ùå Usuario no encontrado");
                return;
            }
            const authUrl = trelloService_1.TrelloService.getAuthUrl();
            await ctx.editMessageText("üîë Para conectar con Trello:\n\n" +
                "1. Haz clic en el bot√≥n para autorizar\n" +
                "2. Copia el token que te proporciona Trello\n" +
                "3. Pega el token aqu√≠", {
                reply_markup: new grammy_1.InlineKeyboard().url("üîó Autorizar en Trello", authUrl),
            });
            // Marcar usuario como esperando token
            await userService_1.userService.updateUser(user.id, { waiting_for_token: true });
        }
        catch (error) {
            console.error("Error in connect prompt:", error);
            const fallbackUser = await userService_1.userService.getUserByTelegramId(ctx.from?.id || 0);
            await ctx.editMessageText("‚ùå Error al iniciar conexi√≥n con Trello", {
                reply_markup: (0, settingsKeyboard_1.createSettingsKeyboard)(fallbackUser || { id: 0 }),
            });
        }
    });
    // A√±adir manejador para cerrar
    bot.callbackQuery("close_settings", async (ctx) => {
        await ctx.deleteMessage();
    });
}
