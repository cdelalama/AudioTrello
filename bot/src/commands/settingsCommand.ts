import { Bot, InlineKeyboard } from "grammy";
import { createBoardsKeyboard, createListsKeyboard } from "../keyboards/trelloKeyboards";
import { userService } from "../services/userService";
import { TrelloService } from "../services/trelloService";
import { createSettingsKeyboard } from "../keyboards/settingsKeyboard";
import { User } from "../../types/types";

export function setupSettingsCommand(bot: Bot) {
	bot.command("settings", async (ctx) => {
		try {
			const user = await userService.getUserByTelegramId(ctx.from?.id || 0);
			if (!user) {
				await ctx.reply("‚ùå Usuario no encontrado");
				return;
			}

			await ctx.reply("‚öôÔ∏è Configuraci√≥n de Trello", {
				reply_markup: createSettingsKeyboard(user),
			});
		} catch (error) {
			console.error("Error in settings command:", error);
			await ctx.reply("‚ùå Error al acceder a la configuraci√≥n");
		}
	});

	// Manejador para ver configuraci√≥n actual
	bot.callbackQuery("settings_view", async (ctx) => {
		try {
			const user = await userService.getUserByTelegramId(ctx.from?.id || 0);
			if (!user) {
				await ctx.answerCallbackQuery("‚ùå Usuario no encontrado");
				return;
			}

			const message =
				`üîß *Configuraci√≥n Actual*\n\n` +
				`*Tablero:* ${
					!user.default_board_name ||
					user.default_board_name === null ||
					user.default_board_name === ""
						? "‚ùå No configurado"
						: user.default_board_name
				}\n` +
				`*Lista:* ${
					!user.default_list_name ||
					user.default_list_name === null ||
					user.default_list_name === ""
						? "‚ùå No configurado"
						: user.default_list_name
				}\n` +
				`*Token Trello:* ${user.trello_token ? "‚úÖ Configurado" : "‚ùå No configurado"}`;

			try {
				await ctx.editMessageText(message, {
					parse_mode: "Markdown",
					reply_markup: createSettingsKeyboard(user),
				});
			} catch (editError: any) {
				// Si el error es porque el mensaje es el mismo, solo respondemos con un callback
				if (editError.description?.includes("message is not modified")) {
					await ctx.answerCallbackQuery("‚úÖ Configuraci√≥n actualizada");
					return;
				}
				throw editError; // Re-lanzar otros errores
			}
		} catch (error) {
			console.error("Error viewing settings:", error);
			const fallbackUser = await userService.getUserByTelegramId(ctx.from?.id || 0);
			await ctx.editMessageText("‚ùå Error al mostrar la configuraci√≥n. Int√©ntalo de nuevo.", {
				reply_markup: createSettingsKeyboard(fallbackUser || ({ id: 0 } as User)),
			});
		}
	});

	// Manejador para configurar tablero
	bot.callbackQuery("settings_board", async (ctx) => {
		try {
			const user = await userService.getUserByTelegramId(ctx.from?.id || 0);
			if (!user?.trello_token) {
				await ctx.editMessageText("‚ùå Necesitas autenticarte con Trello primero", {
					reply_markup: createSettingsKeyboard(user || ({ id: 0 } as User)),
				});
				return;
			}

			const boards = await TrelloService.getBoards(user.trello_token);
			if (!boards.length) {
				await ctx.editMessageText("‚ùå No se encontraron tableros en tu cuenta de Trello", {
					reply_markup: createSettingsKeyboard(user || ({ id: 0 } as User)),
				});
				return;
			}

			await ctx.editMessageText("üìã Selecciona un tablero:", {
				reply_markup: createBoardsKeyboard(boards),
			});
		} catch (error) {
			console.error("Error getting boards:", error);
			const fallbackUser = await userService.getUserByTelegramId(ctx.from?.id || 0);
			await ctx.editMessageText("‚ùå Error al obtener los tableros", {
				reply_markup: createSettingsKeyboard(fallbackUser || ({ id: 0 } as User)),
			});
		}
	});

	// Manejador para selecci√≥n de tablero
	bot.callbackQuery(/select_board:(.+)/, async (ctx) => {
		try {
			const boardId = ctx.match[1];
			const user = await userService.getUserByTelegramId(ctx.from?.id || 0);
			if (!user?.trello_token) return;

			const boards = await TrelloService.getBoards(user.trello_token);
			const selectedBoard = boards.find((b) => b.id === boardId);
			if (!selectedBoard) return;

			await userService.updateUser(user.id, {
				default_board_id: boardId,
				default_board_name: selectedBoard.name,
			});

			const lists = await TrelloService.getLists(boardId, user.trello_token);
			await ctx.editMessageText(
				`‚úÖ Tablero seleccionado: *${selectedBoard.name}*\n\nAhora selecciona una lista:`,
				{
					parse_mode: "Markdown",
					reply_markup: createListsKeyboard(lists),
				}
			);
		} catch (error) {
			console.error("Error selecting board:", error);
			const fallbackUser = await userService.getUserByTelegramId(ctx.from?.id || 0);
			await ctx.editMessageText("‚ùå Error al seleccionar el tablero", {
				reply_markup: createSettingsKeyboard(fallbackUser || ({ id: 0 } as User)),
			});
		}
	});

	// Manejador para navegaci√≥n de p√°ginas de tableros
	bot.callbackQuery(/boards_page:(\d+)/, async (ctx) => {
		try {
			const page = parseInt(ctx.match[1]);
			const user = await userService.getUserByTelegramId(ctx.from?.id || 0);
			if (!user?.trello_token) return;

			const boards = await TrelloService.getBoards(user.trello_token);
			await ctx.editMessageText("üìã Selecciona un tablero:", {
				reply_markup: createBoardsKeyboard(boards, page),
			});
		} catch (error) {
			console.error("Error navigating boards:", error);
			await ctx.answerCallbackQuery("‚ùå Error al navegar los tableros");
		}
	});

	// Manejador para selecci√≥n de lista
	bot.callbackQuery(/select_list:(.+)/, async (ctx) => {
		try {
			const listId = ctx.match[1];
			const user = await userService.getUserByTelegramId(ctx.from?.id || 0);
			if (!user?.trello_token || !user.default_board_id) return;

			const lists = await TrelloService.getLists(user.default_board_id, user.trello_token);
			const selectedList = lists.find((l) => l.id === listId);
			if (!selectedList) return;

			await userService.updateUser(user.id, {
				default_list_id: listId,
				default_list_name: selectedList.name,
			});

			await ctx.editMessageText(
				"‚úÖ Configuraci√≥n guardada:\n\n" +
					`*Tablero:* ${user.default_board_name}\n` +
					`*Lista:* ${selectedList.name}`,
				{
					parse_mode: "Markdown",
					reply_markup: createSettingsKeyboard(user || ({ id: 0 } as User)),
				}
			);
		} catch (error) {
			console.error("Error selecting list:", error);
			const fallbackUser = await userService.getUserByTelegramId(ctx.from?.id || 0);
			await ctx.editMessageText("‚ùå Error al seleccionar la lista", {
				reply_markup: createSettingsKeyboard(fallbackUser || ({ id: 0 } as User)),
			});
		}
	});

	// Manejador para cancelar la configuraci√≥n
	bot.callbackQuery("settings_cancel", async (ctx) => {
		try {
			const user = await userService.getUserByTelegramId(ctx.from?.id || 0);
			if (!user) {
				await ctx.answerCallbackQuery("‚ùå Usuario no encontrado");
				return;
			}

			await ctx.editMessageText("‚öôÔ∏è Configuraci√≥n de Trello", {
				reply_markup: createSettingsKeyboard(user || ({ id: 0 } as User)),
			});
		} catch (error) {
			console.error("Error in settings cancel:", error);
			const fallbackUser = await userService.getUserByTelegramId(ctx.from?.id || 0);
			await ctx.editMessageText("‚öôÔ∏è Configuraci√≥n de Trello", {
				reply_markup: createSettingsKeyboard(fallbackUser || ({ id: 0 } as User)),
			});
		}
	});

	// Manejador para configurar lista directamente
	bot.callbackQuery("settings_list", async (ctx) => {
		try {
			const user = await userService.getUserByTelegramId(ctx.from?.id || 0);
			if (!user?.trello_token) {
				await ctx.editMessageText("‚ùå Necesitas autenticarte con Trello primero", {
					reply_markup: createSettingsKeyboard(user || ({ id: 0 } as User)),
				});
				return;
			}

			if (!user.default_board_id) {
				await ctx.editMessageText("‚ùå Primero debes seleccionar un tablero", {
					reply_markup: createSettingsKeyboard(user || ({ id: 0 } as User)),
				});
				return;
			}

			const lists = await TrelloService.getLists(user.default_board_id, user.trello_token);
			await ctx.editMessageText(
				`üìã Selecciona una lista del tablero *${user.default_board_name}*:`,
				{
					parse_mode: "Markdown",
					reply_markup: createListsKeyboard(lists),
				}
			);
		} catch (error) {
			console.error("Error getting lists:", error);
			const fallbackUser = await userService.getUserByTelegramId(ctx.from?.id || 0);
			await ctx.editMessageText("‚ùå Error al obtener las listas", {
				reply_markup: createSettingsKeyboard(fallbackUser || ({ id: 0 } as User)),
			});
		}
	});

	// Manejador para desconectar Trello
	bot.callbackQuery("settings_disconnect", async (ctx) => {
		try {
			const user = await userService.getUserByTelegramId(ctx.from?.id || 0);
			if (!user) {
				await ctx.answerCallbackQuery("‚ùå Usuario no encontrado");
				return;
			}

			// Preguntar confirmaci√≥n
			await ctx.editMessageText(
				"‚ö†Ô∏è *¬øEst√°s seguro de que quieres desconectar Trello?*\n\n" +
					"Se eliminar√°n todas tus configuraciones actuales.",
				{
					parse_mode: "Markdown",
					reply_markup: new InlineKeyboard()
						.text("‚úÖ S√≠, desconectar", "settings_disconnect_confirm")
						.text("‚ùå No, cancelar", "settings_cancel"),
				}
			);
		} catch (error) {
			console.error("Error in disconnect prompt:", error);
			await ctx.answerCallbackQuery("‚ùå Error al procesar la solicitud");
		}
	});

	// Manejador para confirmar desconexi√≥n
	bot.callbackQuery("settings_disconnect_confirm", async (ctx) => {
		try {
			const user = await userService.getUserByTelegramId(ctx.from?.id || 0);
			if (!user) {
				await ctx.answerCallbackQuery("‚ùå Usuario no encontrado");
				return;
			}

			const success = await userService.disconnectTrello(user.id);
			if (success) {
				await ctx.editMessageText(
					"‚úÖ Trello desconectado correctamente\n\n" +
						"Se han eliminado todas las configuraciones.",
					{
						reply_markup: createSettingsKeyboard(user || ({ id: 0 } as User)),
					}
				);
			} else {
				await ctx.editMessageText("‚ùå Error al desconectar Trello", {
					reply_markup: createSettingsKeyboard(user || ({ id: 0 } as User)),
				});
			}
		} catch (error) {
			console.error("Error disconnecting Trello:", error);
			const fallbackUser = await userService.getUserByTelegramId(ctx.from?.id || 0);
			await ctx.editMessageText("‚ùå Error al desconectar Trello", {
				reply_markup: createSettingsKeyboard(fallbackUser || ({ id: 0 } as User)),
			});
		}
	});

	// Manejador para conectar Trello
	bot.callbackQuery("settings_connect", async (ctx) => {
		try {
			const user = await userService.getUserByTelegramId(ctx.from?.id || 0);
			if (!user) {
				await ctx.answerCallbackQuery("‚ùå Usuario no encontrado");
				return;
			}

			const authUrl = TrelloService.getAuthUrl();
			await ctx.editMessageText(
				"üîë Para conectar con Trello:\n\n" +
					"1. Haz clic en el bot√≥n para autorizar\n" +
					"2. Copia el token que te proporciona Trello\n" +
					"3. Pega el token aqu√≠",
				{
					reply_markup: new InlineKeyboard().url("üîó Autorizar en Trello", authUrl),
				}
			);

			// Marcar usuario como esperando token
			await userService.updateUser(user.id, { waiting_for_token: true });
		} catch (error) {
			console.error("Error in connect prompt:", error);
			const fallbackUser = await userService.getUserByTelegramId(ctx.from?.id || 0);
			await ctx.editMessageText("‚ùå Error al iniciar conexi√≥n con Trello", {
				reply_markup: createSettingsKeyboard(fallbackUser || ({ id: 0 } as User)),
			});
		}
	});

	// A√±adir manejador para cerrar
	bot.callbackQuery("close_settings", async (ctx) => {
		await ctx.deleteMessage();
	});
}
